"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

/*
  This deals with sequencing of our async requests. When a lot of requests are firing very close to one another
  and are running in parallel, what happens if they return out of order? It creates a race condition.

  For example, if I type the term "react" in the search box, two queries may be initiated, in parallel.

  1. query for "reac"
  2. query for "react"

  If the query for "react" actually returns **before** the query for "reac",
  we could end up looking at the results for "reac", despite having typed "react" in the search box.

  To deal with this, we keep track of a sequence.
  */
var RequestSequencer =
/*#__PURE__*/
function () {
  function RequestSequencer() {
    (0, _classCallCheck2.default)(this, RequestSequencer);
    (0, _defineProperty2.default)(this, "requestSequence", 0);
    (0, _defineProperty2.default)(this, "lastCompleted", 0);
  }

  (0, _createClass2.default)(RequestSequencer, [{
    key: "next",
    value: function next() {
      return ++this.requestSequence;
    }
  }, {
    key: "isOldRequest",
    value: function isOldRequest(request) {
      return request < this.lastCompleted;
    }
  }, {
    key: "completed",
    value: function completed(request) {
      this.lastCompleted = request;
    }
  }]);
  return RequestSequencer;
}();

exports.default = RequestSequencer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZXF1ZXN0U2VxdWVuY2VyLmpzIl0sIm5hbWVzIjpbIlJlcXVlc3RTZXF1ZW5jZXIiLCJyZXF1ZXN0U2VxdWVuY2UiLCJyZXF1ZXN0IiwibGFzdENvbXBsZXRlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7O0lBY3FCQSxnQjs7Ozs7MkRBQ0QsQzt5REFDRixDOzs7OzsyQkFFVDtBQUNMLGFBQU8sRUFBRSxLQUFLQyxlQUFkO0FBQ0Q7OztpQ0FFWUMsTyxFQUFTO0FBQ3BCLGFBQU9BLE9BQU8sR0FBRyxLQUFLQyxhQUF0QjtBQUNEOzs7OEJBRVNELE8sRUFBUztBQUNqQixXQUFLQyxhQUFMLEdBQXFCRCxPQUFyQjtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgVGhpcyBkZWFscyB3aXRoIHNlcXVlbmNpbmcgb2Ygb3VyIGFzeW5jIHJlcXVlc3RzLiBXaGVuIGEgbG90IG9mIHJlcXVlc3RzIGFyZSBmaXJpbmcgdmVyeSBjbG9zZSB0byBvbmUgYW5vdGhlclxuICBhbmQgYXJlIHJ1bm5pbmcgaW4gcGFyYWxsZWwsIHdoYXQgaGFwcGVucyBpZiB0aGV5IHJldHVybiBvdXQgb2Ygb3JkZXI/IEl0IGNyZWF0ZXMgYSByYWNlIGNvbmRpdGlvbi5cblxuICBGb3IgZXhhbXBsZSwgaWYgSSB0eXBlIHRoZSB0ZXJtIFwicmVhY3RcIiBpbiB0aGUgc2VhcmNoIGJveCwgdHdvIHF1ZXJpZXMgbWF5IGJlIGluaXRpYXRlZCwgaW4gcGFyYWxsZWwuXG5cbiAgMS4gcXVlcnkgZm9yIFwicmVhY1wiXG4gIDIuIHF1ZXJ5IGZvciBcInJlYWN0XCJcblxuICBJZiB0aGUgcXVlcnkgZm9yIFwicmVhY3RcIiBhY3R1YWxseSByZXR1cm5zICoqYmVmb3JlKiogdGhlIHF1ZXJ5IGZvciBcInJlYWNcIixcbiAgd2UgY291bGQgZW5kIHVwIGxvb2tpbmcgYXQgdGhlIHJlc3VsdHMgZm9yIFwicmVhY1wiLCBkZXNwaXRlIGhhdmluZyB0eXBlZCBcInJlYWN0XCIgaW4gdGhlIHNlYXJjaCBib3guXG5cbiAgVG8gZGVhbCB3aXRoIHRoaXMsIHdlIGtlZXAgdHJhY2sgb2YgYSBzZXF1ZW5jZS5cbiAgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcXVlc3RTZXF1ZW5jZXIge1xuICByZXF1ZXN0U2VxdWVuY2UgPSAwO1xuICBsYXN0Q29tcGxldGVkID0gMDtcblxuICBuZXh0KCkge1xuICAgIHJldHVybiArK3RoaXMucmVxdWVzdFNlcXVlbmNlO1xuICB9XG5cbiAgaXNPbGRSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICByZXR1cm4gcmVxdWVzdCA8IHRoaXMubGFzdENvbXBsZXRlZDtcbiAgfVxuXG4gIGNvbXBsZXRlZChyZXF1ZXN0KSB7XG4gICAgdGhpcy5sYXN0Q29tcGxldGVkID0gcmVxdWVzdDtcbiAgfVxufVxuIl19