import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

/*
  This deals with sequencing of our async requests. When a lot of requests are firing very close to one another
  and are running in parallel, what happens if they return out of order? It creates a race condition.

  For example, if I type the term "react" in the search box, two queries may be initiated, in parallel.

  1. query for "reac"
  2. query for "react"

  If the query for "react" actually returns **before** the query for "reac",
  we could end up looking at the results for "reac", despite having typed "react" in the search box.

  To deal with this, we keep track of a sequence.
  */
var RequestSequencer =
/*#__PURE__*/
function () {
  function RequestSequencer() {
    _classCallCheck(this, RequestSequencer);

    _defineProperty(this, "requestSequence", 0);

    _defineProperty(this, "lastCompleted", 0);
  }

  _createClass(RequestSequencer, [{
    key: "next",
    value: function next() {
      return ++this.requestSequence;
    }
  }, {
    key: "isOldRequest",
    value: function isOldRequest(request) {
      return request < this.lastCompleted;
    }
  }, {
    key: "completed",
    value: function completed(request) {
      this.lastCompleted = request;
    }
  }]);

  return RequestSequencer;
}();

export { RequestSequencer as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZXF1ZXN0U2VxdWVuY2VyLmpzIl0sIm5hbWVzIjpbIlJlcXVlc3RTZXF1ZW5jZXIiLCJyZXF1ZXN0U2VxdWVuY2UiLCJyZXF1ZXN0IiwibGFzdENvbXBsZXRlZCJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Ozs7Ozs7OztJQWNxQkEsZ0I7Ozs7Ozs2Q0FDRCxDOzsyQ0FDRixDOzs7OzsyQkFFVDtBQUNMLGFBQU8sRUFBRSxLQUFLQyxlQUFkO0FBQ0Q7OztpQ0FFWUMsTyxFQUFTO0FBQ3BCLGFBQU9BLE9BQU8sR0FBRyxLQUFLQyxhQUF0QjtBQUNEOzs7OEJBRVNELE8sRUFBUztBQUNqQixXQUFLQyxhQUFMLEdBQXFCRCxPQUFyQjtBQUNEOzs7Ozs7U0Fka0JGLGdCIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgVGhpcyBkZWFscyB3aXRoIHNlcXVlbmNpbmcgb2Ygb3VyIGFzeW5jIHJlcXVlc3RzLiBXaGVuIGEgbG90IG9mIHJlcXVlc3RzIGFyZSBmaXJpbmcgdmVyeSBjbG9zZSB0byBvbmUgYW5vdGhlclxuICBhbmQgYXJlIHJ1bm5pbmcgaW4gcGFyYWxsZWwsIHdoYXQgaGFwcGVucyBpZiB0aGV5IHJldHVybiBvdXQgb2Ygb3JkZXI/IEl0IGNyZWF0ZXMgYSByYWNlIGNvbmRpdGlvbi5cblxuICBGb3IgZXhhbXBsZSwgaWYgSSB0eXBlIHRoZSB0ZXJtIFwicmVhY3RcIiBpbiB0aGUgc2VhcmNoIGJveCwgdHdvIHF1ZXJpZXMgbWF5IGJlIGluaXRpYXRlZCwgaW4gcGFyYWxsZWwuXG5cbiAgMS4gcXVlcnkgZm9yIFwicmVhY1wiXG4gIDIuIHF1ZXJ5IGZvciBcInJlYWN0XCJcblxuICBJZiB0aGUgcXVlcnkgZm9yIFwicmVhY3RcIiBhY3R1YWxseSByZXR1cm5zICoqYmVmb3JlKiogdGhlIHF1ZXJ5IGZvciBcInJlYWNcIixcbiAgd2UgY291bGQgZW5kIHVwIGxvb2tpbmcgYXQgdGhlIHJlc3VsdHMgZm9yIFwicmVhY1wiLCBkZXNwaXRlIGhhdmluZyB0eXBlZCBcInJlYWN0XCIgaW4gdGhlIHNlYXJjaCBib3guXG5cbiAgVG8gZGVhbCB3aXRoIHRoaXMsIHdlIGtlZXAgdHJhY2sgb2YgYSBzZXF1ZW5jZS5cbiAgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcXVlc3RTZXF1ZW5jZXIge1xuICByZXF1ZXN0U2VxdWVuY2UgPSAwO1xuICBsYXN0Q29tcGxldGVkID0gMDtcblxuICBuZXh0KCkge1xuICAgIHJldHVybiArK3RoaXMucmVxdWVzdFNlcXVlbmNlO1xuICB9XG5cbiAgaXNPbGRSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICByZXR1cm4gcmVxdWVzdCA8IHRoaXMubGFzdENvbXBsZXRlZDtcbiAgfVxuXG4gIGNvbXBsZXRlZChyZXF1ZXN0KSB7XG4gICAgdGhpcy5sYXN0Q29tcGxldGVkID0gcmVxdWVzdDtcbiAgfVxufVxuIl19