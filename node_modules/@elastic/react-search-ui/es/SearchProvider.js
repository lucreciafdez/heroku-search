import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import PropTypes from "prop-types";
import React, { Component } from "react";
import { SearchDriver } from "@elastic/search-ui";
import SearchContext from "./SearchContext";
import defaultA11yMessages from "./A11yNotifications";
/**
 * The SearchProvider primarily holds a reference to the SearchDriver and
 * exposes it to the rest of the application in a Context.
 */

var SearchProvider =
/*#__PURE__*/
function (_Component) {
  _inherits(SearchProvider, _Component);

  function SearchProvider() {
    var _this;

    _classCallCheck(this, SearchProvider);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SearchProvider).call(this));
    _this.state = {
      driver: null
    };
    return _this;
  }

  _createClass(SearchProvider, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var config = this.props.config; // This initialization is done inside of componentDidMount, because initializing the SearchDriver server side
      // will error out, since the driver depends on window. Placing the initialization inside of componentDidMount
      // assures that it won't attempt to initialize server side.

      var driver = new SearchDriver(_objectSpread({}, config, {
        a11yNotificationMessages: _objectSpread({}, defaultA11yMessages, {}, config.a11yNotificationMessages)
      }));
      this.setState({
        driver: driver
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.state.driver.tearDown();
    }
  }, {
    key: "render",
    value: function render() {
      var children = this.props.children; // Since driver is initialized in componentDidMount above, we are waiting
      // to render until the driver is available.

      if (!this.state.driver) return null; // Passing the entire "this.state" to the Context is significant. Because
      // Context determines when to re-render based on referential identity
      // something like this could cause unnecessary renders:
      //
      // <SearchContext.Provider value={{driver: this.state.driver}}>
      //
      // By passing the entire state, we ensure that re-renders only occur when
      // state is actually updated.

      return React.createElement(SearchContext.Provider, {
        value: this.state
      }, children);
    }
  }]);

  return SearchProvider;
}(Component);

_defineProperty(SearchProvider, "propTypes", {
  children: PropTypes.node.isRequired,
  // Not providing a shape here because the shape matches the shape of
  // SearchDriver. SearchDriver can do it's own parameter validation.
  config: PropTypes.object
});

export default SearchProvider;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TZWFyY2hQcm92aWRlci5qcyJdLCJuYW1lcyI6WyJQcm9wVHlwZXMiLCJSZWFjdCIsIkNvbXBvbmVudCIsIlNlYXJjaERyaXZlciIsIlNlYXJjaENvbnRleHQiLCJkZWZhdWx0QTExeU1lc3NhZ2VzIiwiU2VhcmNoUHJvdmlkZXIiLCJzdGF0ZSIsImRyaXZlciIsImNvbmZpZyIsInByb3BzIiwiYTExeU5vdGlmaWNhdGlvbk1lc3NhZ2VzIiwic2V0U3RhdGUiLCJ0ZWFyRG93biIsImNoaWxkcmVuIiwibm9kZSIsImlzUmVxdWlyZWQiLCJvYmplY3QiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsT0FBT0EsU0FBUCxNQUFzQixZQUF0QjtBQUNBLE9BQU9DLEtBQVAsSUFBZ0JDLFNBQWhCLFFBQWlDLE9BQWpDO0FBRUEsU0FBU0MsWUFBVCxRQUE2QixvQkFBN0I7QUFDQSxPQUFPQyxhQUFQLE1BQTBCLGlCQUExQjtBQUVBLE9BQU9DLG1CQUFQLE1BQWdDLHFCQUFoQztBQUVBOzs7OztJQUlNQyxjOzs7OztBQVFKLDRCQUFjO0FBQUE7O0FBQUE7O0FBQ1o7QUFDQSxVQUFLQyxLQUFMLEdBQWE7QUFDWEMsTUFBQUEsTUFBTSxFQUFFO0FBREcsS0FBYjtBQUZZO0FBS2I7Ozs7d0NBRW1CO0FBQUEsVUFDVkMsTUFEVSxHQUNDLEtBQUtDLEtBRE4sQ0FDVkQsTUFEVSxFQUVsQjtBQUNBO0FBQ0E7O0FBQ0EsVUFBTUQsTUFBTSxHQUFHLElBQUlMLFlBQUosbUJBQ1ZNLE1BRFU7QUFFYkUsUUFBQUEsd0JBQXdCLG9CQUNuQk4sbUJBRG1CLE1BRW5CSSxNQUFNLENBQUNFLHdCQUZZO0FBRlgsU0FBZjtBQU9BLFdBQUtDLFFBQUwsQ0FBYztBQUNaSixRQUFBQSxNQUFNLEVBQU5BO0FBRFksT0FBZDtBQUdEOzs7MkNBRXNCO0FBQ3JCLFdBQUtELEtBQUwsQ0FBV0MsTUFBWCxDQUFrQkssUUFBbEI7QUFDRDs7OzZCQUVRO0FBQUEsVUFDQ0MsUUFERCxHQUNjLEtBQUtKLEtBRG5CLENBQ0NJLFFBREQsRUFHUDtBQUNBOztBQUNBLFVBQUksQ0FBQyxLQUFLUCxLQUFMLENBQVdDLE1BQWhCLEVBQXdCLE9BQU8sSUFBUCxDQUxqQixDQU9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsYUFDRSxvQkFBQyxhQUFELENBQWUsUUFBZjtBQUF3QixRQUFBLEtBQUssRUFBRSxLQUFLRDtBQUFwQyxTQUNHTyxRQURILENBREY7QUFLRDs7OztFQXhEMEJaLFM7O2dCQUF2QkksYyxlQUNlO0FBQ2pCUSxFQUFBQSxRQUFRLEVBQUVkLFNBQVMsQ0FBQ2UsSUFBVixDQUFlQyxVQURSO0FBRWpCO0FBQ0E7QUFDQVAsRUFBQUEsTUFBTSxFQUFFVCxTQUFTLENBQUNpQjtBQUpELEM7O0FBMERyQixlQUFlWCxjQUFmIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyBTZWFyY2hEcml2ZXIgfSBmcm9tIFwiQGVsYXN0aWMvc2VhcmNoLXVpXCI7XG5pbXBvcnQgU2VhcmNoQ29udGV4dCBmcm9tIFwiLi9TZWFyY2hDb250ZXh0XCI7XG5cbmltcG9ydCBkZWZhdWx0QTExeU1lc3NhZ2VzIGZyb20gXCIuL0ExMXlOb3RpZmljYXRpb25zXCI7XG5cbi8qKlxuICogVGhlIFNlYXJjaFByb3ZpZGVyIHByaW1hcmlseSBob2xkcyBhIHJlZmVyZW5jZSB0byB0aGUgU2VhcmNoRHJpdmVyIGFuZFxuICogZXhwb3NlcyBpdCB0byB0aGUgcmVzdCBvZiB0aGUgYXBwbGljYXRpb24gaW4gYSBDb250ZXh0LlxuICovXG5jbGFzcyBTZWFyY2hQcm92aWRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG4gICAgLy8gTm90IHByb3ZpZGluZyBhIHNoYXBlIGhlcmUgYmVjYXVzZSB0aGUgc2hhcGUgbWF0Y2hlcyB0aGUgc2hhcGUgb2ZcbiAgICAvLyBTZWFyY2hEcml2ZXIuIFNlYXJjaERyaXZlciBjYW4gZG8gaXQncyBvd24gcGFyYW1ldGVyIHZhbGlkYXRpb24uXG4gICAgY29uZmlnOiBQcm9wVHlwZXMub2JqZWN0XG4gIH07XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZHJpdmVyOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgY29uZmlnIH0gPSB0aGlzLnByb3BzO1xuICAgIC8vIFRoaXMgaW5pdGlhbGl6YXRpb24gaXMgZG9uZSBpbnNpZGUgb2YgY29tcG9uZW50RGlkTW91bnQsIGJlY2F1c2UgaW5pdGlhbGl6aW5nIHRoZSBTZWFyY2hEcml2ZXIgc2VydmVyIHNpZGVcbiAgICAvLyB3aWxsIGVycm9yIG91dCwgc2luY2UgdGhlIGRyaXZlciBkZXBlbmRzIG9uIHdpbmRvdy4gUGxhY2luZyB0aGUgaW5pdGlhbGl6YXRpb24gaW5zaWRlIG9mIGNvbXBvbmVudERpZE1vdW50XG4gICAgLy8gYXNzdXJlcyB0aGF0IGl0IHdvbid0IGF0dGVtcHQgdG8gaW5pdGlhbGl6ZSBzZXJ2ZXIgc2lkZS5cbiAgICBjb25zdCBkcml2ZXIgPSBuZXcgU2VhcmNoRHJpdmVyKHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGExMXlOb3RpZmljYXRpb25NZXNzYWdlczoge1xuICAgICAgICAuLi5kZWZhdWx0QTExeU1lc3NhZ2VzLFxuICAgICAgICAuLi5jb25maWcuYTExeU5vdGlmaWNhdGlvbk1lc3NhZ2VzXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkcml2ZXJcbiAgICB9KTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuc3RhdGUuZHJpdmVyLnRlYXJEb3duKCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFNpbmNlIGRyaXZlciBpcyBpbml0aWFsaXplZCBpbiBjb21wb25lbnREaWRNb3VudCBhYm92ZSwgd2UgYXJlIHdhaXRpbmdcbiAgICAvLyB0byByZW5kZXIgdW50aWwgdGhlIGRyaXZlciBpcyBhdmFpbGFibGUuXG4gICAgaWYgKCF0aGlzLnN0YXRlLmRyaXZlcikgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBQYXNzaW5nIHRoZSBlbnRpcmUgXCJ0aGlzLnN0YXRlXCIgdG8gdGhlIENvbnRleHQgaXMgc2lnbmlmaWNhbnQuIEJlY2F1c2VcbiAgICAvLyBDb250ZXh0IGRldGVybWluZXMgd2hlbiB0byByZS1yZW5kZXIgYmFzZWQgb24gcmVmZXJlbnRpYWwgaWRlbnRpdHlcbiAgICAvLyBzb21ldGhpbmcgbGlrZSB0aGlzIGNvdWxkIGNhdXNlIHVubmVjZXNzYXJ5IHJlbmRlcnM6XG4gICAgLy9cbiAgICAvLyA8U2VhcmNoQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17e2RyaXZlcjogdGhpcy5zdGF0ZS5kcml2ZXJ9fT5cbiAgICAvL1xuICAgIC8vIEJ5IHBhc3NpbmcgdGhlIGVudGlyZSBzdGF0ZSwgd2UgZW5zdXJlIHRoYXQgcmUtcmVuZGVycyBvbmx5IG9jY3VyIHdoZW5cbiAgICAvLyBzdGF0ZSBpcyBhY3R1YWxseSB1cGRhdGVkLlxuICAgIHJldHVybiAoXG4gICAgICA8U2VhcmNoQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dGhpcy5zdGF0ZX0+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvU2VhcmNoQ29udGV4dC5Qcm92aWRlcj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaFByb3ZpZGVyO1xuIl19